//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using UnityEngine;
namespace SControls
{
	public enum SDirection{
		left,
		top,
		bottom,
		right,
		top_left,
		top_right,
		bottom_left,
		bottom_right,
		none
	}

	public class STouchManager
	{
		private Hashtable buttonStatus = new Hashtable();
		private Hashtable buttonIndex =new Hashtable();
		//Joystick
		private class SButton{
			public SButton(long time,TouchPhase phase){
				this.beginTime = time;
				this.phase = phase;
			}
			public long beginTime = 0;
			public TouchPhase phase;
		}
	
		private Hashtable joystickDirection = new Hashtable();
		private Hashtable oppositiveSide = new Hashtable();
		public STouchManager ()
		{
			joystickDirection.Add((int)KeyCode.A,SDirection.left);
			joystickDirection.Add((int)KeyCode.A+(int)KeyCode.W,SDirection.top_left);
			joystickDirection.Add((int)KeyCode.W,SDirection.top);
			joystickDirection.Add((int)KeyCode.W+(int)KeyCode.D,SDirection.top_right);
			joystickDirection.Add((int)KeyCode.D,SDirection.right);
			joystickDirection.Add((int)KeyCode.D+(int)KeyCode.S,SDirection.bottom_right);
			joystickDirection.Add((int)KeyCode.S,SDirection.bottom);
			joystickDirection.Add((int)KeyCode.S+(int)KeyCode.A,SDirection.bottom_left);

			oppositiveSide.Add(KeyCode.A,KeyCode.D);
			oppositiveSide.Add(KeyCode.W,KeyCode.S);
			oppositiveSide.Add(KeyCode.D,KeyCode.A);
			oppositiveSide.Add(KeyCode.S,KeyCode.W);
		}

		/// <summary>
		//	冒泡排序算法的运作如下：（从后往前）
		//  比较相邻的元素。如果第一个比第二个大，就交换他们两个。
		//	对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
		//	针对所有的元素重复以上的步骤，除了最后一个。
		//	持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。[1] 		
		/// </summary>
		/// <returns>The sort.</returns>
		/// <param name="table">Table.</param>
		private int[] bubbleSort(int[] source){
			int count = buttonStatus.Count;

			int[] final;
			if (source == null) {
				final = new int[count];
				for (int i=0; i<count; i++) {
					final [i] = i;
				}
			} else {
				final = source;
			}
			for(int j=1;j<count;j++){
				for (int i=0; i<buttonStatus.Count-j; i++) {
					int index = final[i];
					//KeyCode code = (KeyCode)buttonIndex[i];
					KeyCode code = (KeyCode)buttonIndex[index];
					SButton pre = buttonStatus[code] as SButton;
					//KeyCode codeNext = (KeyCode)buttonIndex[i+1];
					int index1 = final[i+1];
					KeyCode codeNext = (KeyCode)buttonIndex[index1];
					SButton next = buttonStatus[codeNext] as SButton;
					if(pre.beginTime > next.beginTime){
						final[i]=final[i]+final[i+1];
						final[i+1]=final[i]-final[i+1];
						final[i] = final[i]-final[i+1];
					}
				}
			}
			
			return final;
		}

	

		/// <summary>
		/// should be ticked pre update
		/// as accelerator update method.
		/// 处理方向键2个连按，为了User Define，所以要引入code parse处理
		/// </summary>
		public void Update(KeyCode codeA,KeyCode codeW,KeyCode codeD,KeyCode codeS){
			if(Input.GetKeyDown(codeS)){
				append(KeyCode.S,new SButton(System.DateTime.UtcNow.Ticks,TouchPhase.Began));
				//Debug.Log(System.DateTime.UtcNow.Ticks);
			}
			if(Input.GetKeyDown(codeA)){
				append(KeyCode.A,new SButton(System.DateTime.UtcNow.Ticks, TouchPhase.Began));
			}
			if(Input.GetKeyDown(codeW)){
				append(KeyCode.W,new SButton(System.DateTime.UtcNow.Ticks,TouchPhase.Began));

			}
			if(Input.GetKeyDown(codeD)){
				append(KeyCode.D,new SButton(System.DateTime.UtcNow.Ticks,TouchPhase.Began));
			}
			//if(Input.GetKey(KeyCode.S)){
			//	append(buttonStatus,KeyCode.S,TouchPhase.Moved);
			//}
			//			else if(Input.GetKey(KeyCode.A)){
			//				append(buttonStatus,KeyCode.A,TouchPhase.Moved);
			//			}else if(Input.GetKey(KeyCode.W)){
			//				append(buttonStatus,KeyCode.W,TouchPhase.Moved);
			//			}else if(Input.GetKey(KeyCode.D)){
			//				append(buttonStatus,KeyCode.D,TouchPhase.Moved);
			//	}
			if(Input.GetKeyUp(codeS)){
				append(KeyCode.S,new SButton(0, TouchPhase.Ended));
			}
			if(Input.GetKeyUp(codeW)){
				append(KeyCode.W,new SButton(0,TouchPhase.Ended));
			}
			if(Input.GetKeyUp(codeA)){
				append(KeyCode.A,new SButton(0,TouchPhase.Ended));
			}
			if(Input.GetKeyUp(codeD)){
				append(KeyCode.D,new SButton(0,TouchPhase.Ended));
			}



		}
		/// <summary>
		/// 取最后2个按钮，如果互斥，才再取前一个比较
		/// </summary>
		/// <returns>The parse combo.</returns>
		/// <param name="code">Code.</param>
		public SDirection buttonParseCombo(){
			//Debug.Log(buttonStatus.Count+"xCount");
			int[] ints = bubbleSort (null);
			//int[] convertInts = new int[4];
//			for (int i=0; i<ints.Length; i++) {
//				convertInts[i]=ints[i];
//			}
//			for (int i = 0; i < 4-ints.Length; i++) {
//				convertInts[i+ints.cou]=new SButton(0,TouchPhase.Ended);
//			}
			String strs="";
			String keys = "";
			string times = "";
			foreach(int i in ints){
				strs+=i+"|";
				KeyCode code = (KeyCode)buttonIndex[i];
				keys+=Enum.GetName(typeof(KeyCode),code);
				SButton btn = buttonStatus[code] as SButton;
				times+=btn.beginTime + "|";
			}

			//Debug.Log (strs + ","+keys+","+times);
			SDirection direct=SDirection.none;
			//val second button
			if(ints.Length>0){
				int iLastButton = ints.Length - 1;
				KeyCode code = (KeyCode)buttonIndex[ints[iLastButton]];
				SButton btn = buttonStatus[code] as SButton;
				if(btn.beginTime > 0 && ints.Length>1){
				
					KeyCode code2 = (KeyCode)buttonIndex[ints[ints.Length-2]];
					SButton btnSec = buttonStatus[code2] as SButton;
					if(btnSec.beginTime==0){
						direct = (SDirection) joystickDirection[(int)code];
					}
					else
					{
						KeyCode codeOp = (KeyCode)oppositiveSide[code];
						if(codeOp == code2){
							if(ints.Length>2){
								KeyCode code3 = (KeyCode)buttonIndex[ints[ints.Length-3]];
								SButton btnTrd = buttonStatus[code3] as SButton;
								if(btnTrd.beginTime==0){
									direct = (SDirection)joystickDirection[(int)code];
								}else{
									direct = (SDirection)joystickDirection[(int)code+(int)code3];
								}
							}else{
								direct = (SDirection)joystickDirection[(int)code2];
							}
						}
						else{
							direct =(SDirection)joystickDirection[(int)code + (int)code2];
						}
					}
				}else{
					direct = (SDirection) joystickDirection[(int)code];
				}
			}
			//Debug.Log ("direct:"+Enum.GetName(typeof(SDirection),direct));
			return direct;

			//			bool bol = true;
			//			if(code == KeyCode.S){
			//				foreach(DictionaryEntry entry  in buttonStatus){
			//					KeyCode key = (KeyCode)entry.Key;
			//					if(key==KeyCode.W){
			//						SButton btnS = buttonStatus[KeyCode.S] as SButton;
			//						SButton button = entry.Value as SButton;
			//						if(btnS.beginTime > button.beginTime){
			//							bol =  false;
			//						}
			//
			//						bol= true;
			//					}
			//					//assume onlys have a and d key.
			//					bol= true;
			//				}
			//			}else if(code == KeyCode.A){
			//				foreach(DictionaryEntry entry in buttonStatus){
			//					KeyCode key = (KeyCode)entry.Key;
			//					if(key==KeyCode.D){
			//						SButton btnA = buttonStatus[KeyCode.A] as SButton;
			//						SButton button = entry.Value as SButton;
			//						if(btnA.beginTime>button.beginTime){
			//							bol= false;
			//						}
			//						bol= true;
			//					}
			//				}
			//				//assue that only have w or s keycode
			//				bol= true;
			//			}
			//
			//			if(bol==true){
			//				if(code==KeyCode.S){
			//
			//				}
			//				return SDirection.bottom;
			//			}else{
			//				return SDirection.none;
			//			}
		}
		private void append(KeyCode code,SButton btn){
			if(buttonStatus.ContainsKey(code)==false){
				buttonStatus.Add(code, btn);
				bool isExist = false;
				foreach(DictionaryEntry entry in buttonIndex){
					KeyCode value = (KeyCode)entry.Value;
					if(value==code){
						//do nothing
						isExist =true;
					}
				}
				if(isExist==false){
					buttonIndex.Add(buttonIndex.Count,code);
				}
			}
			else{
				SButton button =  buttonStatus[code] as SButton;
				button.beginTime = btn.beginTime;
				button.phase = btn.phase;

			}
		}
	}
}

